// auto generated by pocketlib.nut
// This is the entire orange library condensed into one script.

// orange_api_util.nut

::liborange <- class { // not a table so that ::display(sector) doesnt flood the console with orange api stuff
	other_data = {}
}

function get_sector() {
	try {
		return sector
	} 	catch(e) {
		try {
			return worldmap
		} catch(e) {
			return {}
		}
	}
}

function api_table() {
	if(!("liborange" in get_sector())) get_sector().liborange <- liborange
	return liborange
}
function api_storage() return api_table().other_data
function api_sector_storage() {
	if(!("_liborange_other_data" in get_sector())) get_sector()._liborange_other_data <- class{}
	return get_sector()._liborange_other_data
}

function help() display_text_file("orange-api/help.stxt")

function distance_from_point_to_point(...) {
	local x1 = 0
	local y1 = 0
	local x2 = 0
	local y2 = 0
	switch(vargv.len()) {
		case 2: // distance_from_point_to_point(pos1, pos2)
			x1 = vargv[0].x
			x2 = vargv[1].x
			y1 = vargv[0].y
			y2 = vargv[1].y
		break
		case 4: // distance_from_point_to_point(x1, y1, x2, y2)
			x1 = vargv[0]
			x2 = vargv[2]
			y1 = vargv[1]
			y2 = vargv[3]
		break
		default:
			throw "wrong number of parameters"
		break
	}
	return sqrt(pow((x2 - x1), 2) + pow((y2 - y1), 2))
}

function get_players(include_OObjects = true) {
    local arroy = {}
    foreach(i, v in get_sector()) if("use_scripting_controller" in v || (include_OObjects && "is_OObject" in v && "use_scripting_controller" in v.object))
		arroy[i] <- v
    return arroy
}

function get_nearest_player(x, y) {
	local closest_pos = -1
	local closest_object
	foreach(i, v in get_players()) {
		local new_pos = distance_from_point_to_point(x, y, v.get_x(), v.get_y())
		if(new_pos < closest_pos || closest_pos < 0) {
			closest_object = v
			closest_pos = new_pos
		}
	}
	return closest_object
}

function objects_collided(x1, y1, w1, h1, x2, y2, w2, h2, direction = "auto")
	return ((direction == "up" || direction == "top" || direction == "auto") && (y1 + h1 <= y2 + 1))
	|| ((direction == "down" || direction == "bottom" || direction == "auto") && (y1 >= y2 + h2 - 1))
	|| ((direction == "left" || direction == "auto") && (x1 >= x2 + w2 - 1))
	|| ((direction == "right" || direction == "auto") && (x1 + w1 <= x2 + 1))

function collided_with_any_player(x1, y1, w1, h1, direction = "auto") {
	local collided = {}
	foreach(i, player in get_players())
		if(objects_collided(player.get_x(), player.get_y(), 32, (player.get_bonus() == "none" ? 32 : 64), x1, y1, w1, h1, direction))
			collided[1] <- player
	return collided
}

// some scripts shouldnt trigger on the worldmap. any scripts that shouldnt trigger should have some sorta `if(WORLDMAP_GUARD)` somewhere in it
// this variable is true if youre not on the worldmap
function WORLDMAP_GUARD() {
	try {
		return sector != null
	} catch(e) return false
}
::WORLDMAP_GUARD <- WORLDMAP_GUARD()
::SECTOR_GUARD <- !WORLDMAP_GUARD


// callback.nut

class OCallback {
	connections = null

	fire = null
	emit = null

	constructor() {
		connections = []

		fire = call
		emit = call
	}

	function connect(...) {
		if(type(vargv[0]) == "string") {
			vargv[0] = compilestring(vargv[0])
		}
		switch(vargv.len()) {
			case 1: // connect(func)
				connections.push(vargv[0])
			break
			case 2: // connect(env, func)
				print("[liborange] The function `OCallback.connect(env, func)` is deprecated. Please use `OCallback.connect(func)` or `OCallback.connect(func.bindenv(env))` instead.")
				connections.push(vargv[1].bindenv(vargv[0]))
			break
			default:
				throw "wrong number of parameters"
			break
		}
	}

	function disconnect(func) {
		connections.remove(connections.find(func))
	}

	function call(...) foreach(connection in connections) {
		connection.acall([this].extend(vargv))
	}
}

api_table().Callback <- OCallback

api_table().add_callback <- function(name) {
	if(!("OCallbacks" in api_sector_storage())) api_sector_storage().OCallbacks <- {}
	api_sector_storage().OCallbacks[name.tolower()] <- OCallback()
}

api_table().get_callback <- function(name) {
	if(!("OCallbacks" in api_sector_storage())) api_table().add_callback(name)
	if(!(name in api_sector_storage().OCallbacks)) api_table().add_callback(name)
	return api_sector_storage().OCallbacks[name.tolower()]
}

api_table().remove_callback <- function(name) {
	if(!("OCallbacks" in api_sector_storage())) api_sector_storage().OCallbacks <- {}
	delete api_sector_storage().OCallbacks[name.tolower()]
}


// containers.nut

// containers

class OVector {
	x = null
	y = null

	constructor(...) {
		switch(vargv.len()) {
			case 0: // OVector()
				x = 0
				y = 0
			break
			case 2: // OVector(x, y)
				x = vargv[0]
				y = vargv[1]
			break
			default:
				throw "wrong number of parameters"
			break
		}
	}

	function distance_to(...) {
		switch(vargv.len()) {
			case 1: // distance_to(other)
				return api_table().distance_rom_point_to_point(this, vargv[0])
			break
			case 2: // distance_to(other_x, other_y)
				return api_table().distance_rom_point_to_point(x, y, vargv[0], vargv[1])
			break
		}
	}

	function _add(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OVector(x + other, y + other)
		}
		return OVector(x + other.x, x + other.y)
	}

	function _sub(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OVector(x - other, y - other)
		}
		return OVector(x - other.x, x - other.y)
	}

	function _mul(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OVector(x * other, y * other)
		}
		return OVector(x * other.x, x * other.y)
	}

	function _div(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OVector(x / other, y / other)
		}
		return OVector(x / other.x, x / other.y)
	}

	function _modulo(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OVector(x % other, y % other)
		}
		return OVector(x % other.x, x % other.y)
	}

	function _unm() {
		return OVector(-x, -y)
	}

	function _typeof() {
		return "vector"
	}

	function _cmp(other) {
		return (x + y) * 0.5 <=> (other.x + other.y) * 0.5
	}

	function _cloned(original) {
		x = original.x
		y = original.y
	}

	function _tostring() {
		return "Vector(" + x + ", " + y + ")"
	}
}

class ORect {
	position = null
	size = null

	constructor(...) {
		switch(vargv.len()) {
			case 0: // ORect()
				position = OVector()
				size = OVector()
			break
			case 2: // ORect(position = OVector(), size = OVector())
				position = vargv[0]
				size = vargv[1]
			break
			case 4: // ORect(x = 0, y = 0, w = 0, h = 0)
				position = OVector(vargv[0], vargv[1])
				size = OVector(vargv[2], vargv[3])
			break
			default:
				throw "wrong number of parameters"
			break
		}
	}

	function grow(border) {
		if(size.x + border * 2 < 0 || size.y + border * 2 < 0) return

		position -= border
		size += border
	}

	function grown(border) {
		local retval = clone this
		retval.grow(border)
		return retval
	}

	function left() {
		return position.x
	}

	function down() {
		return position.y + size.y
	}

	function up() {
		return position.y
	}

	function right() {
		return position.x + size.x
	}

	function _add(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return ORect(position + other, size + other)
		}
		return ORect(position + other.position, size + other.size)
	}

	function _sub(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return ORect(position - other, size - other)
		}
		return ORect(position - other.position, size - other.size)
	}

	function _mul(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return ORect(position * other, size * other)
		}
		return ORect(position * other.position, size * other.size)
	}

	function _div(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return ORect(position / other, size / other)
		}
		return ORect(position / other.position, size / other.size)
	}

	function _modulo(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return ORect(position % other, size % other)
		}
		return ORect(position % other.position, size % other.size)
	}

	function _typeof() {
		return "rect"
	}

	function _unm() {
		return ORect(-position, -size)
	}

	function _cmp(other) {
		return (position + size) * 0.5 <=> (other.position + other.size) * 0.5
	}

	function _cloned(original) {
		position = original.position
		size = original.size
	}

	function _tostring() {
		return "Rect(" + position.x + ", " + position.y + ", " + size.x + ", " + size.y + ")"
	}
}

class OColor {
	r = null
	g = null
	b = null
	a = null

	constructor(...) {
		switch(vargv.len()) {
			case 0: // OColor()
				r = 0
				g = 0
				b = 0
				a = 1
			break
			case 3: // OColor(r, g, b)
				r = vargv[0]
				g = vargv[1]
				b = vargv[2]
				a = 1
			break
			case 4: // OColor(r, g, b, a)
				r = vargv[0]
				g = vargv[1]
				b = vargv[2]
				a = vargv[3]
			break
			default:
				throw "wrong number of parameters"
			break
		}
	}

	function is_valid() {
		return r > 0 && r < 1 &&
				g > 0 && g < 1 &&
				b > 0 && b < 1 &&
				a > 0 && a < 1
	}

	function validate() {
		if(r < 0) r = 0
		if(r > 1) r = 1
		if(g < 0) g = 0
		if(g > 1) g = 1
		if(b < 0) b = 0
		if(b > 1) b = 1
		if(a < 0) a = 0
		if(a > 1) a = 1
	}

	function validated() {
		local retval = clone this
		retval.validate()
		return retval
	}

	function greyscale() {
		local averaged = (r + g + b) / 3
		r = averaged
		g = averaged
		b = averaged
	}

	function greyscaled() {
		local retval = clone this
		retval.greyscale()
		return retval
	}

	/*
	Basically:
		- convert the current RGB values to HSV
		- shift the H in the new values
		- convert back to RGB
	*/
	/*function hue_shift(degrees) {
		// convert the current RGB values to HSV
		local h
		local s
		local v

		local max = api_table().max(r, g, b)
		local delta = max - api_table().min(r, g, b)

		if(delta > 0) {
			if(max == r) {
				h = 60 * ((g - b) / delta) % 6
			} else if(max == g) {
				h = 60 * (((b - r) / delta) + 2)
			} else if(max == b) {
				h = 60 * (((r - g) / delta) + 4)
			}

			if(max > 0) {
				s = delta / max
			} else {
				s = 0
			}

		} else {
			h = 0
			s = 0
		}

		v = max

		if(h < 0) {
			h = 360 + h
		}

		// shift the H in the new values
		h += degrees

		// convert back to RGB
		local c = v * s // Chroma
		local h_prime = h / (60.0 % 6)
		local x = c * (1 - fabs((h_prime % 2) - 1))
		local m = v - c

		if(0 <= h_prime && h_prime < 1) {
			r = c
			g = x
			b = 0
		} else if(1 <= h_prime && h_prime < 2) {
			r = x
			g = c
			b = 0
		} else if(2 <= h_prime && h_prime < 3) {
			r = 0
			g = c
			b = x
		} else if(3 <= h_prime && h_prime < 4) {
			r = 0
			g = x
			b = c
		} else if(4 <= h_prime && h_prime < 5) {
			r = x
			g = 0
			b = c
		} else if(5 <= h_prime && h_prime < 6) {
			r = c
			g = 0
			b = x
		} else {
			r = 0
			g = 0
			b = 0
		}

		r += m
		g += m
		b += m
	}*/

	function _add(other) {
		return OColor(r + other.r, g + other.g, b + other.b, a + other.a)
	}

	function _sub(other) {
		return OColor(r - other.r, g - other.g, b - other.b, a - other.a)
	}

	function _mul(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OColor(r * other, g * other, b * other, a * other)
		}
		return OColor(r * other.r, g * other.g, b * other.b, a * other.a)
	}

	function _div(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OColor(r / other, g / other, b / other, a / other)
		}
		return OColor(r / other.r, g / other.g, b / other.b, a / other.a)
	}

	function _modulo(other) {
		if(type(other) == "integer" || type(other) == "float") {
			return OColor(r % other, g % other, b % other, a % other)
		}
		return OColor(r % other.r, g % other.g, b % other.b, a % other.a)
	}

	function _typeof() {
		return "color"
	}

	function _unm() {
		return OColor(-r, -g, -b, -a)
	}

	function _cmp(other) {
		return (r + g + b + a) * 0.25 <=> (other.r + other.g + other.b + other.a) * 0.25
	}

	function _cloned(original) {
		r = original.r
		g = original.g
		b = original.b
		a = original.a
	}

	function _tostring() {
		return "Color(" + r + ", " + g + ", " + b + ", " + a + ")"
	}
}

api_table().Vector <- OVector
api_table().Rect <- ORect
api_table().Color <- OColor

// helper functions

api_table().parse_color <- function(args, func_name) {
	switch(args.len()) {
		case 1:
			if(type(args[0]) == "string") { // func_name("COLOR_NAME")
				object[func_name](api_table().colors[args[0]].r,
									api_table().colors[args[0]].g,
									api_table().colors[args[0]].b,
									api_table().colors[args[0]].a)
			} else { // func_name(OColor(...))
				args[0].validate()
				object[func_name](args[0].r, args[0].g, args[0].b, args[0].a)
			}
		break
		case 3: // func_name(r, g, b)
			object[func_name](args[0], args[1], args[2], 1)
		break
		case 4: // func_name(r, g, b, a)
			object[func_name](args[0], args[1], args[2], args[3])
		break
		default:
			throw "wrong number of parameters"
		break
	}
}

api_table().parse_color_no_alpha <- function(args, func_name) {
	switch(args.len()) {
		case 1:
			if(type(args[0]) == "string") { // func_name("COLOR_NAME")
				object[func_name](api_table().colors[args[0]].r,
									api_table().colors[args[0]].g,
									api_table().colors[args[0]].b)
			} else { // func_name(OColor(...))
				args[0].validate()
				object[func_name](args[0].r, args[0].g, args[0].b)
			}
		break
		case 3: // func_name(r, g, b)
			object[func_name](args[0], args[1], args[2])
		break
		default:
			throw "wrong number of parameters"
		break
	}
}


// control.nut

::controls <- [
"left"
"right"
"up"
"down"
"jump"
"action"
"start"
"escape"
"menu-select"
"menu-select-space"
"menu-back"
"remove"
"cheat-menu"
"debug-menu"
"console"
"peek-left"
"peek-right"
"peek-up"
"peek-down"
]

api_table().wait_for_any_pressed <- function(player = 1) {
	local input = null
	while(input == null) {
		if(player < 1) {
			foreach(v in get_players()) foreach(w in controls) {
				if(v.get_input_pressed(w)) input = w
			}
		} else foreach(v in controls) if(get_sector()["Tux" + (player == 1 ? "" : player.tostring())].get_input_pressed(v)) input = v
		wait(0.01)
	}
	return input
}

api_table().anyone_pressed <- function(input) foreach(v in get_players()) if(v.get_input_pressed(input)) return v

api_table().anyone_held <- function(input) foreach(v in get_players()) if(v.get_input_held(input)) return v

api_table().anyone_released <- function(input) foreach(v in get_players()) if(v.get_input_released(input)) return v

api_table().anyone_axis <- function(negative, positive) {
	local axis = 0
	foreach(v in get_players()) {
		if(v.get_input_held(negative))
			axis--
		if(v.get_input_held(positive))
			axis++
	}
	if(axis == 0) {
		return 0
	} else return (axis > 0 ? 1 : -1)
}


// factory.nut

class OGameObject {
	RAW = 0

	_class_name = null
	name = ""
	x = 0
	y = 0
	direction = "auto"
	data = null

	data_string = ""

	constructor(classname, _name = "", _x = 0, _y = 0, _direction = "auto", _data = null) {
		RAW = ::rand().tostring()
		_class_name = classname
		name = _name
		x = _x
		y = _y
		direction = _direction
		data = (_data == null) ? {} : _data
	}

	function set_pos(_x, _y) {
		x = _x
		y = _y
	}

	function set_data(key, value) {
		data[key] <- value
	}

	function get_data(key) {
		return key in data ? data[key] : null
	}

	function has_data(key) {
		return key in data
	}

	function delete_data(key) {
		delete data[key]
	}

	function add_raw_data(string) {
		data[string] <- RAW
	}

	function parse_data() {
		data_string = ""
		foreach(i, v in data) {
			if(v == RAW) {
				data_string += i + "\n"
				continue
			}
			data_string += ::api_table().table_to_sexp({[i] = v}) + "\n"
		}
	}

	function initialize(overrides = {}, return_object = true) {
		parse_data()
		local unexposed = false
		local x_ = x
		local y_ = y
		local name_ = "name" in overrides ? overrides.name : name
		local class_name_ = "class_name" in overrides ? overrides.class_name : class_name
		if("pos_x" in overrides) x_ = overrides.pos_x
		if("pos_y" in overrides) y_ = overrides.pos_y
		if("x" in overrides) x_ = overrides.x
		if("y" in overrides) y_ = overrides.y
		if(return_object && name_ == "") {
			name_ = "unexposeme-" + ::rand()
			unexposed = true
		}
		if(class_name_ == "scriptedobject") {
			set_data("name", name_)
			parse_data()
		}
		::get_sector().settings.add_object(class_name_, name_, x_, y_, "direction" in overrides ? overrides.direction : direction, data_string)
		if(!return_object) return
		//local guh = 0
		while(!(name_ in ::get_sector())) {
		//	guh++
			wait(0)
		}
		//::print("[liborange] Took " + guh + " frames to spawn " + name_ + ".")
		local obj = ::get_sector()[name_]
		if(unexposed) ::get_sector()[name_] = null // the key cant be deleted or it will throw errors
		return obj
	}

	function print_sexp() {
		parse_data()
		::display("\n" + api_table().replace("(" + class_name +
				"\n(name \"" + name +
				"\")\n(x " + x +
				")\n(y " + y +
				")\n(direction \"" + direction +
				"\")\n" + data_string,
				"\n", "\n  ") + "\n)\n")
	}

	function _set(key, value) {
		if(key == "class_name") {
			value = value.tolower()
			if(value == "checkpoint") {
				return _class_name = "firefly"
			} else {
				return _class_name = value
			}
		}
		if(key == "pos_x") return x = value
		if(key == "pos_y") return y = value

		set_data(key, value)
	}

	function _get(key) {
		if(key == "class_name") {
			if(_class_name == "firefly") {
				return "checkpoint"
			} else {
				return _class_name
			}
		}
		if(key == "pos_x") return x
		if(key == "pos_y") return y

		if(has_data(key)) return get_data(key)

		throw null
	}

	function _newslot(key, value) {
		set_data(key, value)
	}

	function _delslot(key) {
		delete_data(key)
	}
}

api_table().GameObject <- OGameObject


// math.nut

api_table().min <- function(...) {
	local smallest
	foreach(v in vargv)
		if(smallest == null || v < smallest)
			smallest = v
	return smallest
}

api_table().max <- function(...) {
	local biggest
	foreach(v in vargv)
		if(biggest == null || v > biggest)
			biggest = v
	return biggest
}

api_table().round <- function(x) return x - floor(x) < 0.5 ? floor(x) : ceil(x)


// misc.nut

api_table().char_at_index <- function(string, index) return string.slice(index, api_table().mod_max(index + 1, string.len()))

api_table().distance_from_point_to_point <- distance_from_point_to_point

api_table().table_to_sexp <- function(table) {
	local retstring = ""
	foreach(i, v in table) {
		local retstring2 = ""
		if(type(v) == "string") {
			retstring2 += "(" + i.tostring() + " \"" + v + "\")"
		} else if(type(v) == "bool") {
			retstring2 += "(" + i.tostring() + " " + (v ? "#t" : "#f") + ")"
		} else retstring2 += "(" + i.tostring() + " " + v.tostring() + ")"
		if(i.find("_")) retstring2 += api_table().table_to_sexp({[api_table().replace(i, "_", "-")] = v})
		retstring += retstring2
	}
	return retstring
}

api_table().add_object <- function(class_name, name = "", x = 0, y = 0, direction = "auto", data = "", return_object = true) {
	print(getstackinfos(2).src + " on line " + getstackinfos(2).line)
	print("[liborange] `liborange.add_object()` is deprecated. Please use `liborange.GameObject()` instead.")

	if(name == "") return_object = false
	if(type(data) == "table") data = api_table().table_to_sexp(data)
	local unexposed = name.tolower() == "unexposeme"
	if(unexposed) name += "-" + class_name + "-" + rand().tostring()
	if(class_name == "checkpoint") class_name = "firefly" //somebody change this please
	if(class_name == "scriptedobject" && !data.find("(name") && name != "") data += @"(name """ + name + @""")"
	get_sector().settings.add_object(class_name, name, x, y, direction, data)
	if(return_object) {
		while(!(name in get_sector())) wait(0)
		local retvalue = get_sector()[name]
		if(unexposed) get_sector()[name] = null // the key cant be deleted because it will throw errors
		return retvalue
	}
}

/*api_table().add_object <- function(class_name, name = "", x = 0, y = 0, direction = "auto", data = "", return_object = true) {
	print(getstackinfos(2).src + " on line " + getstackinfos(2).line)
	print("[liborange] `liborange.add_object()` is deprecated. Please use `liborange.GameObject()` instead.")
	local object = api_table().GameObject(class_name)
	object.set_pos(x, y)
	object.direction = direction
	if(type(data) == "string") {
		object.add_raw_data(data)
	} else object.data = data
	return object.initialize({}, return_object)
}*/

api_table().replace <- function(string, findstring, replacestring) {
	local newstring = ""
	for(local i = 0; i < string.len(); i++) {
		local a = string.slice(i,  i + 1)
		if(a == findstring) {
			newstring += replacestring
		} else newstring += a
	}
	return newstring
}


// oobject.nut

class OObject {
	static is_OObject = true

	object = null
	object_name = ""
	odata = null

	// sector_ref = null

	constructor(obj) {
		odata = {} // we dont want all odatas to point to the same table
		if(::type(obj) == "string") {
			if("is_OObject" in ::get_sector()[obj]) {
				object = ::get_sector()[obj].object
			} else object = ::get_sector()[obj]
			delete ::get_sector()[obj]
			::get_sector()[obj] <- this
		} else {
			if("is_OObject" in obj) {
				object = obj.object
			} else object = obj
		}
		if("get_name" in object) {
			object_name = object.get_name()
		} else object_name = obj.tostring()

		// sector_ref = ::get_sector()
	}

	function display(ANY) ::display(ANY) // for convenience
	function print(object) ::print(object)

	function set_everything(stuff) foreach(i, v in stuff) if("set_" + i in this) this["set_" + i].acall([object].extend(type(v) == "array" ? v : [v]))

	// no `get_everything()` because it would be kinda complicated considering i cant iterate over a class instance

	// function in_current_sector() return sector_ref != null && sector_ref == ::get_sector()

	function get_name() return object_name

	function _get(key) { // Returning just the function doesnt work. We need to bind the object to the enviroment to get it to work.
		if(key == "get_x" && "get_pos_x" in object) {
			return object.get_x.bindenv(object)
		} else if(key == "get_y" && "get_pos_y" in object) {
			return object.get_y.bindenv(object)
		} else if(key in object) {
			if(::type(object[key]) == "function") {
				return object[key].bindenv(object)
			} else {
				return object[key]
			}
		} else if(key in odata) {
			return odata[key]
// Godot-like get_*() and set_*() functions. if theres a variable in an OObject called `value` then typing `OObject.get_value()` will return `value`
		} /*else if(key.slice(0, 4) == "get_") {
			return function[this]() return this[key.slice(4)]
		}else if(key.slice(0, 4) == "set_") {
			return function[this](value) return this[key.slice(4)] = value
		}*/
		throw null
	}

	function _set(key, value) {
		if(key in odata) return odata[key] = value
		throw null
	}

	function _newslot(key, value) {
		return odata[key] <- value
	}

	function _delslot(key) {
		return delete odata[key]
    }
}

api_table().Object <- OObject
api_table().OObject <- OObject

api_table().convert_to_OObject <- function(sector = get_sector())
	foreach(i, v in sector)
		if(type(v) == "instance" && !("is_OObject" in v))
			OObject(i)

api_table().init_objects <- function(obj_name, obj_class, ...) {
	local params = (vargv.len() > 0 && type(vargv[0]) == "array") ? vargv[0] : vargv
	foreach(i, v in sector)
		if(startswith(i, obj_name) && !("is_OObject" in v))
			obj_class.instance().constructor.acall([obj_class.instance(), i].extend(params))
}


// signal.nut

class OSignal extends OCallback {
	function connect(func) {
		if(type(func) == "string") {
			func = compilestring(func)
        }
        connections.push(func)
	}

	function call(...) foreach(connection in connections) {
		local a = ::newthread(connection)
		api_table().thread_fix(a)
		a.call.acall([a].extend(vargv))
	}
}

api_table().Signal <- OSignal
api_table().signal <- OSignal // compatibility

api_table().init_callbacks <- function() {
	local added_players = {}
	while(wait(0) == null) {
		foreach(i, v in get_players()) {
			if(!(i in added_players)) {
				added_players[i] <- v
				api_table().get_signal("player-added").call(v, i)
			} else if(added_players.len() > get_players().len()) {
				foreach(i, v in added_players)
					if(!(i in get_players())) {
						api_table().get_signal("player-removed").call(v, i)
						delete added_players[i]
					}
			}
			foreach(v in added_players) foreach(w in controls) {
				if(v.get_input_pressed(w)) api_table().get_signal("input-pressed").call(w, v)
			//	if(v.get_input_held(w)) api_table().get_signal("input-held").call(w, v)
				if(v.get_input_released(w)) api_table().get_signal("input-released").call(w, v)
			}
		}
		api_table().get_callback("process").call()
	}
}

api_table().init_signals <- function() if(!("signals_innitted" in api_sector_storage())) {
	api_sector_storage().signals_innitted <- true
	api_table().sector_thread(api_table().init_callbacks).wakeup()
}

api_table().add_signal <- function(name) {
	if(!("OSignals" in api_sector_storage())) api_sector_storage().OSignals <- {}
	api_sector_storage().OSignals[name.tolower()] <- OSignal()
}

api_table().get_signal <- function(name) {
	if(name == "process") throw getstackinfos(2).src + " line " + getstackinfos(2).line + ". If this is not your doing, report this to Orange immediately."
	if(!("OSignals" in api_sector_storage())) api_table().add_signal(name)
	if(!(name in api_sector_storage().OSignals)) api_table().add_signal(name)
	return api_sector_storage().OSignals[name.tolower()]
}

api_table().remove_signal <- function(name) {
	if(!("OSignals" in api_sector_storage())) api_sector_storage().OSignals <- {}
	delete api_sector_storage().OSignals[name.tolower()]
}


// text.nut

enum keys { // i hate how i have to define these so many times
	TEXT
	SWAP
	FUNC
	BACK
	CUSTOM
	EXIT
}

enum values {
	NULL
	INT
	FLOAT
	STRING
	BOOL
	ENUM
}

enum errors {
	OK
	INFO
	WARNING
	ERROR
}

// functions to make menu things
::action <- {}

function action::text(text)  return {
	key = keys.TEXT
	text = "- " + text + " -"
	skip = true
}

function action::swap(text, menu) return {
	key = keys.SWAP
	menu = menu
	text = text
}

function action::run(text, func, envobj = null) return {
	key = keys.FUNC
	func = func
	text = text
	envobj = envobj
}

function action::back(text = "Back") return {
	key = keys.BACK
	text = text
}

function action::exit(text = "Exit") return {
	key = keys.EXIT
	text = text
}

// data types
::data <- {}

function data::integer(text, num = 0, min = -2147483647, max = 2147483647, inc = 1) return {
	key = keys.CUSTOM
	value = values.INT
	text = text

	num = num
	min = min
	max = max
	inc = inc
}

function data::float(text, num = 0.0, min = -2147483647.0, max = 2147483647.0, inc = 0.5) return {
	key = keys.CUSTOM
	value = values.FLOAT
	text = text

	num = num
	min = min
	max = max
	inc = inc
}

function data::string(text, string = "", prefix = "\"", suffix = "\"") return {
	key = keys.CUSTOM
	value = values.STRING
	text = text

	string = string
	prefix = prefix
	suffix = suffix
}

function data::bool(text, bool = false, true_text = "ON", false_text = "OFF") return {
	key = keys.CUSTOM
	value = values.BOOL
	text = text

	bool = bool
	true_text = true_text
	false_text = false_text
}

function data::enums(text, index, ...) return {
	key = keys.CUSTOM
	value = values.ENUM
	text = text
	enums = vargv
	index = index
}

function data::nil(text) return {
	key = keys.CUSTOM
	value = values.NULL
	text = text
}

function get_pressed(...) {
	foreach(v in vargv) if(sector.Tux.get_input_pressed(v)) return true
	return false
}
function get_held(...) {
	foreach(v in vargv) if(sector.Tux.get_input_held(v)) return true
	return false
}
function get_released(...) {
	foreach(v in vargv) if(sector.Tux.get_input_released(v)) return true
	return false
}

class OText extends OObject {
	text = ""

	constructor(name = null) {
		if(name == null) {
			base.constructor(::TextObject())
		} else base.constructor(name)
	}

	// overridden functions

	function set_text(_text = "") {
		text = _text
		// _text = api_table().replace(_text, "\n", "\n\n")
		_text = api_table().replace(_text, "\t", "  ")
		object.set_text(_text)
	}

	function set_front_fill_color(...) {
		api_table().parse_color.bindenv(this)(vargv, "set_front_fill_color")
	}

	function set_back_fill_color(...) {
		api_table().parse_color.bindenv(this)(vargv, "set_back_fill_color")
	}

	function set_text_color(...) {
		api_table().parse_color.bindenv(this)(vargv, "set_text_color")
	}

	//OText specific functions

	function get_pos() {
		return api_table().Vector(get_x(), get_y())
	}

	function get_text() return text

	function add_text(_text) set_text(get_text() + _text)

	function typewrite(display_text, wait_time = 0.05, wait_on_end_chars = true) {
		for(local i = 0; i < display_text.len(); i++) {
			set_text(display_text.slice(0, i))
			//wait(wait_time)
		}
	}
}

class OMenuText extends OText {
	visible = false
	exited = null

	menu = []
	selected = 0

	//history = []
	last_menu = null

	constructor(name = null) {
		base.constructor(name)
		set_centered(true)
		process = process_func.bindenv(this)
		input_pressed = input_pressed_func.bindenv(this)
		api_table().init_signals()
		exited = OSignal()
	}

	function update(_visible) {
		visible = _visible
		selected = 0
		if(visible) {
			api_table().get_callback("process").connect(process)
			api_table().get_signal("input-pressed").connect(input_pressed)
		} else {
			api_table().get_callback("process").disconnect(process)
			api_table().get_signal("input-pressed").disconnect(input_pressed)
			exited.call()
		}
	}

	function swap_menu(new_menu) {
		//history.push(menu)
		last_menu = menu
		//menu = clone new_menu
		menu = new_menu
		selected = 0
	}

	function select() {
		local selected_item = menu[selected]
		switch(selected_item.key) {
			case keys.SWAP:
				swap_menu(selected_item.menu)
			break
			case keys.FUNC:
				if(selected_item.envobj == null) {
					selected_item.func()
				} else {
					selected_item.func.bindenv(selected_item.envobj)()
				}
			break
			case keys.BACK:
				swap_menu(last_menu)
			break
			case keys.EXIT:
				set_visible(false)
			break
		}
	}

	function change_value(amount) {
		local selected_item = menu[selected]
		switch(selected_item.value) {
			case values.INT:
			case values.FLOAT:
				if(api_table().anyone_held("action")) {
					amount = amount * (selected_item.value == values.INT ? 2 : 0.1)
				}
				if(api_table().anyone_held("menu-select")) {
					amount = amount * (selected_item.value == values.INT ? 10 : 0.5)
				}
				selected_item.num += amount
			break
			//case values.STRING:
				// nothing yet (how am i supposed to do this?)
			//break
			case values.BOOL:
				selected_item.bool = !selected_item.bool
			break
			case values.ENUM:
				selected_item.index += amount
				if(selected_item.index < 0)
					selected_item.index = selected_item.enums.len() - 1
				if(selected_item.index >= selected_item.enums.len())
					selected_item.index = 0
			break
		}
	}

	function move_selected(amount) {
		selected += amount
		if(selected < 0) selected = menu.len() - 1
		if(selected >= menu.len()) selected = 0
	}

	process = null
	function process_func() {
		local selected_item = menu[selected]
		if("skip" in selected_item) {
			local a = api_table().anyone_axis("up", "down") +
					api_table().anyone_axis("peek-up", "peek-down")
			move_selected(a == 0 ? 1 : a)
			return
		}
		set_text("")
		foreach(i, item in menu) {
			add_text(i == selected ? "> " : " ")
			add_text(item.text)
			if(item.key == keys.CUSTOM) {
				add_text(" = ")
				switch(item.value) {
					case values.INT:
						add_text(item.num)
					break
					case values.FLOAT:
						add_text(item.num)
						if(floor(item.num) == item.num) {
							add_text(".0")
						}
					break
					case values.STRING:
						add_text(item.prefix + item.string + item.suffix)
					break
					case values.BOOL:
						add_text((item.bool ? item.true_text : item.false_text))
					break
					case values.ENUM:
						add_text(item.enums[item.index])
					break
					case values.NULL:
						add_text("<null>")
					break
					default:
						add_text("???")
					break
				}
			}
			add_text(i == selected ? " <" : "")
			if(i < menu.len() - 1) add_text("\n")
		}
	}

	input_pressed = null
	function input_pressed_func(input, player) {
		local selected_item = menu[selected]
		move_selected(api_table().anyone_axis("up", "down") +
					api_table().anyone_axis("peek-up", "peek-down"))
		if(input == "menu-select") {
			if(selected_item.key == keys.CUSTOM) {
				change_value(1)
			} else {
				select()
			}
		}
		local horiz_axis = api_table().anyone_axis("left", "right") +
		api_table().anyone_axis("peek-left", "peek-right")
		if(horiz_axis != 0 && selected_item.key == keys.CUSTOM) {
			change_value(horiz_axis)
		}
	}

	function set_visible(_visible) {
		object.set_visible(_visible)
		update(_visible)
	}

	function fade_in(fadetime) {
		object.fade_in(fadetime)
		update(true)
	}

	function fade_out(fadetime) {
		object.fade_out(fadetime)
		update(false)
	}

	function grow_in(fadetime) {
		object.grow_in(fadetime)
		update(true)
	}

	function grow_out(fadetime) {
		object.grow_out(fadetime)
		update(false)
	}
}

api_table().Text <- OText
api_table().MenuText <- OMenuText


// thread.nut

function OThread(func) {
	::print("[liborange] The class \"liborange.Thread()\" is deprecated. Use \"newthread()\" in combination with \"liborange.thread_fix()\" instead.")
	::print(getstackinfos(2).src + " : line " + getstackinfos(2).line)
	::print(startswith(getstackinfos(2).src, "liborange") || startswith(getstackinfos(2).src, "orange-api") ? "Please report to Orange with the above info." : "...")
	local object = ::newthread(::type(func) == "string" ? compilestring(func) : func)
	if(!("OThreads" in ::api_storage())) ::api_storage().OThreads <- []
	::api_storage().OThreads.push(object)
	return object
}

api_table().Thread <- OThread
api_table().thread <- OThread

api_table().thread_fix <- function(thread) {
	if(!("OThreads" in ::api_storage())) ::api_storage().OThreads <- []
	::api_storage().OThreads.push(thread)
}

if(WORLDMAP_GUARD) {
	local thread_object = OGameObject("scripttrigger")
	thread_object.width = 1
	thread_object.height = 1
	thread_object.oneshot = true
	thread_object.button = false

	api_table().sector_thread <- function(func, wakeup_param = false, return_thread = true) {
		local id = rand()
		if(type(func) == "string") func = compilestring(func)

		if(!("thread_ids" in sector)) sector.thread_ids <- {}
		sector.thread_ids[id] <- {
			func = func
			wakeup_param = wakeup_param
		}

		if(return_thread) {
			thread_object.script = @"
				local func = sector.thread_ids[" + id + @"].func
				local wakeup_param = sector.thread_ids[" + id + @"].wakeup_param
				sector.thread_ids[" + id + @"].thread <- get_current_thread()
				if(wakeup_param) {
					func(::suspend())
				} else {
					::suspend()
					func()
				}"
		} else {
			thread_object.script = "sector.thread_ids[" + id + "].func()"
		}

		if(return_thread) {
			local obj = thread_object.initialize()
			while(!("thread" in sector.thread_ids[id])) {
				wait(0)
				obj.set_pos(sector.Tux.get_x() + 16, sector.Tux.get_y() + 16)
			}
		} else {
			local name = rand() + "" + rand()
			thread_object.initialize(
				{
					name = name,
					x = sector.Tux.get_x() + 16,
					y = sector.Tux.get_y() + 16
				}, false)
			api_table().get_callback("process").connect(function() {
				if(name in sector) {
					sector[name].set_pos(sector.Tux.get_x() + 16, sector.Tux.get_y() + 16)
					api_table().get_callback("process").disconnect(callee())
				}
			})
		}
		local thread
		if(return_thread) {
			thread = sector.thread_ids[id].thread
			return thread
		}
	}
}

// background.nut

class OBackground extends OObject {
	animation_frames = []
	thread = null
	playing = false
	speed = 1

	constructor(name) {
		base.constructor(name)
		thread = newthread(thread_func.bindenv(this))
		thread.call()
	}

	function thread_func() {
		local inc = 0
		while(wait(speed) == null) {
			if(playing && animation_frames.len() > 0) {
				//display(animation_frames[inc % animation_frames.len()])
				set_images("top" in animation_frames[inc % animation_frames.len()] ? animation_frames[inc % animation_frames.len()].top : "images/background/misc/transparent_up.png"
						   "middle" in animation_frames[inc % animation_frames.len()] ? animation_frames[inc % animation_frames.len()].middle : "images/background/misc/transparent_up.png"
						   "bottom" in animation_frames[inc % animation_frames.len()] ? animation_frames[inc % animation_frames.len()].bottom : "images/background/misc/transparent_up.png"
				)
				inc++
			}
		}
	}

	function set_animation_frames(...) animation_frames = vargv
	function add_animation_frame(top = null, middle = null, bottom = null) {
		animation_frames.push({
			top = top != null ? top : "images/background/misc/transparent_up.png"
			middle = middle != null ? middle : "images/background/misc/transparent_up.png"
			bottom = bottom != null ? bottom : "images/background/misc/transparent_up.png"
		})
	}
	function clear_animation_frames() animation_frames = [{}]

	function set_animation_speed(seconds) speed = seconds
	function set_animation_fps(fps) set_animation_speed(fps / 60)

	function play_animation() playing = true
	function pause_animation() playing = false
}

api_table().Background <- OBackground


// badguy.nut

enum directions {
	AUTO
	LEFT
	RIGHT
	UP
	DOWN
}

function dir_to_int(dir) switch(dir) {
	case directions.LEFT:
	case directions.UP:
		return -1
	case directions.RIGHT:
	case directions.DOWN:
		return 1
	default:
		return 0
}

class OBadguy extends OObject {
	health = null
	direction = null

	constructor(name, _direction = directions.AUTO, _health = 1) {
		health = _health
		if(_direction = directions.AUTO) {
			direction = get_nearest_player(get_x(), get_y()).get_x() > get_x() ? directions.RIGHT : directions.LEFT
		} else direction = _direction
		base.constructor(name)
	}

	function is_burnable() return true
	function is_freezable() return true
	function is_slideable() return true

	function touched() {}

	function kill() {}

	function ignite() if(is_burnable()) kill()
}

class OWalkingBadguy extends OBadguy {
	speed = null
	is_walking = false
	thread = null

	constructor(name, _direction = directions.AUTO, _speed = 80, _health = 1) {
		speed = _speed
		if(_direction = directions.AUTO) {
			direction = get_nearest_player(get_x(), get_y()).get_x() > get_x() ? directions.RIGHT : directions.LEFT
		} else direction = _direction
		base.constructor(name, _direction, _health)
		thread = newthread(thread_func.bindenv(this))
		thread.call()
	}

	function thread_func() {
		while(wait(0.01) == null) {
			if(get_x() == 0 && is_walking) turn_around()
		}
	}

	function walk() {
		is_walking = true
		set_velocity(speed * dir_to_int(direction), get_y())
	}

	function stop_walking() {
		is_walking = false
		set_velocity(0, get_y())
	}

	function turn_around() {
		switch(direction) {
			case directions.LEFT:
				direction = directions.RIGHT
				break
			case directions.RIGHT:
				direction = directions.LEFT
				break
		}
		if(is_walking) walk()
	}
}

api_table().Badguy <- OBadguy

api_table().WalkingBadguy <- OWalkingBadguy


// bumper.nut

if(WORLDMAP_GUARD) {

class OBumper extends OObject {
	direction = null
	speed_x = 0
	speed_y = 0

	constructor(obj, dir = "right", x = 700, y = -450) {
		base.constructor(obj)
		direction = dir.tolower()
		speed_x = x
        speed_y = y

		set_action("normal-" + direction)
	}

	function press() {
		force_press(get_nearest_player(get_x(), get_y()))
	}

	function force_press(player = sector.Tux) {
		player.deactivate()
		wait(0.01)
		local y_speed = (
			(player.get_action().find("slide-") && get_y() - 31 <= player.get_y())
			|| player.get_action().find("swim-")
			|| player.get_action().find("boost-")
			|| player.get_action().find("float-")
		) ? player.get_velocity_x() : speed_y
		player.set_velocity((direction == "right" ? speed_x : speed_x * -1), y_speed)
		play_sound("sounds/trampoline.wav")
		set_action("swinging-" + direction)
		while(player.get_velocity_y() < 0) {
			if(player.get_input_held("left")) player.set_dir(false)
			if(player.get_input_held("right")) player.set_dir(true)
			wait(0.01)
		}
		set_action("normal-" + direction)
		player.activate()
	}

	//push = press
	//unpush = unpress
	//force_push = force_press
}

api_table().Bumper <- OBumper

}

// button.nut

if(WORLDMAP_GUARD) {

class OButton extends OObject {
	direction = null
	press_function = null

	is_pressed = false

	button_x = 0
	button_y = 0

	constructor(obj, dir = "up", func = function(){}) {
		base.constructor(obj)
		direction = dir.tolower()
		if(type(func) == "string") {
			press_function = compilestring(func)
		} else press_function = func
		button_x = get_x()
		button_y = get_y()

		set_action("off-" + direction)
	}

	function press(...) {
		local sound = true
		foreach(v in vargv)
			if(type(v) == "string") {
				press_function = compilestring(v)
			} else if(type(v) == "function") {
				press_function = v
			} else if(type(v) == "bool") sound = v
		if(collided_with_any_player(get_x(), get_y(),
									((direction == "up" || direction == "down") ? 30 : 16),
									((direction == "up" || direction == "down") ? 16 : 30), direction).len() > 0)
			force_press(sound)
	}

	function force_press(sound = true) {
		if(!is_pressed) {
			is_pressed = true
			local a = newthread(press_function)
			api_table().thread_fix(a)
			a.call()
			set_action("on-" + direction)
			if(sound) play_sound("sounds/switch.ogg")
			wait(0.01)
			if(direction == "up") set_pos(button_x, button_y + 6)
			if(direction == "right") set_pos(button_x + 6, button_y)
		}
	}

	function unpress(sound = false) {
		if(is_pressed) {
			is_pressed = false
			set_action("off-" + direction)
			if(sound) play_sound("sounds/switch.ogg")
			wait(0.01)
			if(direction == "up") set_pos(button_x, button_y)
			if(direction == "right") set_pos(button_x, button_y)
		}
	}

	//push = press
	//unpush = unpress
	//force_push = force_press
}

api_table().Button <- OButton

}

// camera.nut

if(WORLDMAP_GUARD) {

enum camera_mode {
	MANUAL
	NORMAL
}

class OCamera extends OObject {
	mode = camera_mode.NORMAL

	default_drag = 0.01

	x_bounds = 150 // How far the camera goes in front of Tux. Where can i find this value in the source?
	x_speed = 1

	y_bounds = 3.5

	drag = null

	target = sector.Tux

	y_checking = false

	top_y = 9999999999

	cur_x = 0
	cur_y = null

	stopped = false

	constructor(name) {
		base.constructor(name)
		cur_y = target.get_y() - (get_height() * 0.5) + 16
		y_bounds = get_height() / y_bounds
		reset_drag()
		object.set_mode("manual")
		api_table().get_callback("process").connect(process_func.bindenv(this))
		api_table().init_signals()
	}

	function process_func() {
		if(stopped) return
		if(get_y() < top_y && y_checking) {
			top_y = get_y()
			print(top_y)
		}
		switch(mode) {
			case camera_mode.NORMAL:
				object.scroll_to(target.get_x() - (get_width() * 0.5) + 16 + cur_x, cur_y, drag)

				if(target.get_velocity_x() != 0) {
					cur_x += x_speed * target.get_velocity_x() / 125
					if(cur_x > x_bounds) cur_x = x_bounds
					if(cur_x < x_bounds * -1) cur_x = x_bounds * -1
				}

				if(get_y() + y_bounds > target.get_y()) cur_y = target.get_y() - y_bounds
				if(get_y() + get_height() - y_bounds < target.get_y()) cur_y = target.get_y() + y_bounds - get_height()
			break
		}
	}

	// overridden functions

	function set_mode(_mode) {
		if(_mode.tolower() == "normal") mode = camera_mode.NORMAL
		if(_mode.tolower() == "manual") mode = camera_mode.MANUAL
	}

	function set_pos(x, y) {
		mode = camera_mode.MANUAL
		object.set_pos(x, y)
	}

	function move(x, y) set_pos(get_x() + x, get_y() + y)

	function scroll_to(x, y, scrolltime) {
		mode = camera_mode.MANUAL
		object.scroll_to(x, y, scrolltime)
	}

	// OCamera specific functions

	function stop() {
		stopped = true
		sector.Camera <- object
	}

	function get_mode() switch (mode) {
		case camera_mode.NORMAL:
			return "normal"
		case camera_mode.MANUAL:
			return "manual"
		default:
			return "unknown"
	}

	function set_target(_target, smooth = true) {
		target = ("is_OObject" in _target) ? _target : OObject(_target)
		if(smooth) {
			local a = newthread(function() {
				local target_drag = get_drag()
				set_drag(100)
				while(wait(0.01) == null) {
					set_drag(get_drag() + (target_drag > get_drag() ? 1 : -1))
					if(abs(get_drag()) < 2) {
						set_drag(target_drag)
						break
					}
				}
			}.bindenv(this))
			api_table().thread_fix(a)
			a.call()
		}
	}

	/*function scale_to_objects(object_a, object_b, time) {
		if(!("is_OObject" in object_a)) object_a = OObject(object_a)
		if(!("is_OObject" in object_b)) object_b = OObject(object_b)
		local scale_at_1 = get_width() * get_scale()
		local distance_x = abs(object_a.get_x() - object_b.get_x())
		local distance_y = abs(object_a.get_y() - object_b.get_y())
		local distance = distance_x > distance_y ? distance_x : distance_y
		local newpos_x = object_a.get_x() < object_b.get_x() ? object_a.get_x() : object_b.get_x()
		local newpos_y = object_a.get_y() < object_b.get_y() ? object_a.get_y() : object_b.get_y()
		local div = scale_at_1 / distance
		scroll_to(newpos_x, newpos_y, time)
		scale_anchor(div, time, ANCHOR_BOTTOM_RIGHT)
		scale_anchor(div, time, ANCHOR_TOP_LEFT)
	}*/

	function set_drag(_drag) drag = _drag * 0.01
	function get_drag() return drag * 100
	function reset_drag() drag = default_drag

	function get_width() return get_screen_width()
	function get_height() return get_screen_height()
	function get_scale() return get_current_scale()
}

api_table().Camera <- OCamera

api_table().init_camera <- function() OCamera("Camera")

}


// class.nut

/*
use like:

class newclass extends liborange.combined_class(class1, class2) {
    constructor() {
        base1.constructor()
        base2.constructor()
    }
}
*/
api_table().combined_class <- function(classa, classb) {
	class newclass {
		base1 = classa.instance()
		base2 = classb.instance()
	}
	foreach(i, v in classa) newclass[i] <- v
	foreach(i, v in classb) newclass[i] <- v
	return newclass
}

// colors.nut

// List taken from Godot's documentation. https://docs.godotengine.org/en/4.1/classes/class_color.html#constants

local colors = {
	ALICE_BLUE = OColor(0.941176, 0.972549, 1, 1)
	ANTIQUE_WHITE = OColor(0.980392, 0.921569, 0.843137, 1)
	AQUA = OColor(0, 1, 1, 1)
	AQUAMARINE = OColor(0.498039, 1, 0.831373, 1)
	AZURE = OColor(0.941176, 1, 1, 1)
	BEIGE = OColor(0.960784, 0.960784, 0.862745, 1)
	BISQUE = OColor(1, 0.894118, 0.768627, 1)
	BLACK = OColor(0, 0, 0, 1)
	BLANCHED_ALMOND = OColor(1, 0.921569, 0.803922, 1)
	BLUE = OColor(0, 0, 1, 1)
	BLUE_VIOLET = OColor(0.541176, 0.168627, 0.886275, 1)
	BROWN = OColor(0.647059, 0.164706, 0.164706, 1)
	BURLYWOOD = OColor(0.870588, 0.721569, 0.529412, 1)
	CADET_BLUE = OColor(0.372549, 0.619608, 0.627451, 1)
	CHARTREUSE = OColor(0.498039, 1, 0, 1)
	CHOCOLATE = OColor(0.823529, 0.411765, 0.117647, 1)
	CORAL = OColor(1, 0.498039, 0.313726, 1)
	CORNFLOWER_BLUE = OColor(0.392157, 0.584314, 0.929412, 1)
	CORNSILK = OColor(1, 0.972549, 0.862745, 1)
	CRIMSON = OColor(0.862745, 0.0784314, 0.235294, 1)
	CYAN = OColor(0, 1, 1, 1)
	DARK_BLUE = OColor(0, 0, 0.545098, 1)
	DARK_CYAN = OColor(0, 0.545098, 0.545098, 1)
	DARK_GOLDENROD = OColor(0.721569, 0.52549, 0.0431373, 1)
	DARK_GRAY = OColor(0.662745, 0.662745, 0.662745, 1)
	DARK_GREEN = OColor(0, 0.392157, 0, 1)
	DARK_KHAKI = OColor(0.741176, 0.717647, 0.419608, 1)
	DARK_MAGENTA = OColor(0.545098, 0, 0.545098, 1)
	DARK_OLIVE_GREEN = OColor(0.333333, 0.419608, 0.184314, 1)
	DARK_ORANGE = OColor(1, 0.54902, 0, 1)
	DARK_ORCHID = OColor(0.6, 0.196078, 0.8, 1)
	DARK_RED = OColor(0.545098, 0, 0, 1)
	DARK_SALMON = OColor(0.913725, 0.588235, 0.478431, 1)
	DARK_SEA_GREEN = OColor(0.560784, 0.737255, 0.560784, 1)
	DARK_SLATE_BLUE = OColor(0.282353, 0.239216, 0.545098, 1)
	DARK_SLATE_GRAY = OColor(0.184314, 0.309804, 0.309804, 1)
	DARK_TURQUOISE = OColor(0, 0.807843, 0.819608, 1)
	DARK_VIOLET = OColor(0.580392, 0, 0.827451, 1)
	DEEP_PINK = OColor(1, 0.0784314, 0.576471, 1)
	DEEP_SKY_BLUE = OColor(0, 0.74902, 1, 1)
	DIM_GRAY = OColor(0.411765, 0.411765, 0.411765, 1)
	DODGER_BLUE = OColor(0.117647, 0.564706, 1, 1)
	FIREBRICK = OColor(0.698039, 0.133333, 0.133333, 1)
	FLORAL_WHITE = OColor(1, 0.980392, 0.941176, 1)
	FOREST_GREEN = OColor(0.133333, 0.545098, 0.133333, 1)
	FUCHSIA = OColor(1, 0, 1, 1)
	GAINSBORO = OColor(0.862745, 0.862745, 0.862745, 1)
	GHOST_WHITE = OColor(0.972549, 0.972549, 1, 1)
	GOLD = OColor(1, 0.843137, 0, 1)
	GOLDENROD = OColor(0.854902, 0.647059, 0.12549, 1)
	GRAY = OColor(0.745098, 0.745098, 0.745098, 1)
	GREEN = OColor(0, 1, 0, 1)
	GREEN_YELLOW = OColor(0.678431, 1, 0.184314, 1)
	HONEYDEW = OColor(0.941176, 1, 0.941176, 1)
	HOT_PINK = OColor(1, 0.411765, 0.705882, 1)
	INDIAN_RED = OColor(0.803922, 0.360784, 0.360784, 1)
	INDIGO = OColor(0.294118, 0, 0.509804, 1)
	IVORY = OColor(1, 1, 0.941176, 1)
	KHAKI = OColor(0.941176, 0.901961, 0.54902, 1)
	LAVENDER = OColor(0.901961, 0.901961, 0.980392, 1)
	LAVENDER_BLUSH = OColor(1, 0.941176, 0.960784, 1)
	LAWN_GREEN = OColor(0.486275, 0.988235, 0, 1)
	LEMON_CHIFFON = OColor(1, 0.980392, 0.803922, 1)
	LIGHT_BLUE = OColor(0.678431, 0.847059, 0.901961, 1)
	LIGHT_CORAL = OColor(0.941176, 0.501961, 0.501961, 1)
	LIGHT_CYAN = OColor(0.878431, 1, 1, 1)
	LIGHT_GOLDENROD = OColor(0.980392, 0.980392, 0.823529, 1)
	LIGHT_GRAY = OColor(0.827451, 0.827451, 0.827451, 1)
	LIGHT_GREEN = OColor(0.564706, 0.933333, 0.564706, 1)
	LIGHT_PINK = OColor(1, 0.713726, 0.756863, 1)
	LIGHT_SALMON = OColor(1, 0.627451, 0.478431, 1)
	LIGHT_SEA_GREEN = OColor(0.12549, 0.698039, 0.666667, 1)
	LIGHT_SKY_BLUE = OColor(0.529412, 0.807843, 0.980392, 1)
	LIGHT_SLATE_GRAY = OColor(0.466667, 0.533333, 0.6, 1)
	LIGHT_STEEL_BLUE = OColor(0.690196, 0.768627, 0.870588, 1)
	LIGHT_YELLOW = OColor(1, 1, 0.878431, 1)
	LIME = OColor(0, 1, 0, 1)
	LIME_GREEN = OColor(0.196078, 0.803922, 0.196078, 1)
	LINEN = OColor(0.980392, 0.941176, 0.901961, 1)
	MAGENTA = OColor(1, 0, 1, 1)
	MAROON = OColor(0.690196, 0.188235, 0.376471, 1)
	MEDIUM_AQUAMARINE = OColor(0.4, 0.803922, 0.666667, 1)
	MEDIUM_BLUE = OColor(0, 0, 0.803922, 1)
	MEDIUM_ORCHID = OColor(0.729412, 0.333333, 0.827451, 1)
	MEDIUM_PURPLE = OColor(0.576471, 0.439216, 0.858824, 1)
	MEDIUM_SEA_GREEN = OColor(0.235294, 0.701961, 0.443137, 1)
	MEDIUM_SLATE_BLUE = OColor(0.482353, 0.407843, 0.933333, 1)
	MEDIUM_SPRING_GREEN = OColor(0, 0.980392, 0.603922, 1)
	MEDIUM_TURQUOISE = OColor(0.282353, 0.819608, 0.8, 1)
	MEDIUM_VIOLET_RED = OColor(0.780392, 0.0823529, 0.521569, 1)
	MIDNIGHT_BLUE = OColor(0.0980392, 0.0980392, 0.439216, 1)
	MINT_CREAM = OColor(0.960784, 1, 0.980392, 1)
	MISTY_ROSE = OColor(1, 0.894118, 0.882353, 1)
	MOCCASIN = OColor(1, 0.894118, 0.709804, 1)
	NAVAJO_WHITE = OColor(1, 0.870588, 0.678431, 1)
	NAVY_BLUE = OColor(0, 0, 0.501961, 1)
	OLD_LACE = OColor(0.992157, 0.960784, 0.901961, 1)
	OLIVE = OColor(0.501961, 0.501961, 0, 1)
	OLIVE_DRAB = OColor(0.419608, 0.556863, 0.137255, 1)
	ORANGE = OColor(1, 0.647059, 0, 1)
	ORANGE_RED = OColor(1, 0.270588, 0, 1)
	ORCHID = OColor(0.854902, 0.439216, 0.839216, 1)
	PALE_GOLDENROD = OColor(0.933333, 0.909804, 0.666667, 1)
	PALE_GREEN = OColor(0.596078, 0.984314, 0.596078, 1)
	PALE_TURQUOISE = OColor(0.686275, 0.933333, 0.933333, 1)
	PALE_VIOLET_RED = OColor(0.858824, 0.439216, 0.576471, 1)
	PAPAYA_WHIP = OColor(1, 0.937255, 0.835294, 1)
	PEACH_PUFF = OColor(1, 0.854902, 0.72549, 1)
	PERU = OColor(0.803922, 0.521569, 0.247059, 1)
	PINK = OColor(1, 0.752941, 0.796078, 1)
	PLUM = OColor(0.866667, 0.627451, 0.866667, 1)
	POWDER_BLUE = OColor(0.690196, 0.878431, 0.901961, 1)
	PURPLE = OColor(0.627451, 0.12549, 0.941176, 1)
	REBECCA_PURPLE = OColor(0.4, 0.2, 0.6, 1)
	RED = OColor(1, 0, 0, 1)
	ROSY_BROWN = OColor(0.737255, 0.560784, 0.560784, 1)
	ROYAL_BLUE = OColor(0.254902, 0.411765, 0.882353, 1)
	SADDLE_BROWN = OColor(0.545098, 0.270588, 0.0745098, 1)
	SALMON = OColor(0.980392, 0.501961, 0.447059, 1)
	SANDY_BROWN = OColor(0.956863, 0.643137, 0.376471, 1)
	SEA_GREEN = OColor(0.180392, 0.545098, 0.341176, 1)
	SEASHELL = OColor(1, 0.960784, 0.933333, 1)
	SIENNA = OColor(0.627451, 0.321569, 0.176471, 1)
	SILVER = OColor(0.752941, 0.752941, 0.752941, 1)
	SKY_BLUE = OColor(0.529412, 0.807843, 0.921569, 1)
	SLATE_BLUE = OColor(0.415686, 0.352941, 0.803922, 1)
	SLATE_GRAY = OColor(0.439216, 0.501961, 0.564706, 1)
	SNOW = OColor(1, 0.980392, 0.980392, 1)
	SPRING_GREEN = OColor(0, 1, 0.498039, 1)
	STEEL_BLUE = OColor(0.27451, 0.509804, 0.705882, 1)
	TAN = OColor(0.823529, 0.705882, 0.54902, 1)
	TEAL = OColor(0, 0.501961, 0.501961, 1)
	THISTLE = OColor(0.847059, 0.74902, 0.847059, 1)
	TOMATO = OColor(1, 0.388235, 0.278431, 1)
	TRANSPARENT = OColor(1, 1, 1, 0)
	TURQUOISE = OColor(0.25098, 0.878431, 0.815686, 1)
	VIOLET = OColor(0.933333, 0.509804, 0.933333, 1)
	WEB_GRAY = OColor(0.501961, 0.501961, 0.501961, 1)
	WEB_GREEN = OColor(0, 0.501961, 0, 1)
	WEB_MAROON = OColor(0.501961, 0, 0, 1)
	WEB_PURPLE = OColor(0.501961, 0, 0.501961, 1)
	WHEAT = OColor(0.960784, 0.870588, 0.701961, 1)
	WHITE = OColor(1, 1, 1, 1)
	WHITE_SMOKE = OColor(0.960784, 0.960784, 0.960784, 1)
	YELLOW = OColor(1, 1, 0, 1)
	YELLOW_GREEN = OColor(0.603922, 0.803922, 0.196078, 1)
}

local colors_delegate = {
	_get = function(key) {
		if(key == "RANDOM" || key == "RANDOM_NOAPLHA") return colors.random()
		if(key == "RANDOM_APLHA") return colors.random(true)

		throw null
	}
}

colors.from_255 <- function(r, g, b, a = 0xFF) return OColor(r / 0xFF, g / 0xFF, b / 0xFF, a / 0xFF)
colors.from_888 <- colors.from_255

colors.from_hex <- function(hex) {
	if(type(hex) == "string") {
		hex = hex.tolower()
		if(startswith(hex, "#")) {
			hex = hex.slice(1)
		} else if(startswith(hex, "0x")) hex = hex.slice(2)
		return from_255(
			hex_bit_to_number(hex.slice(0, 2)),
			hex_bit_to_number(hex.slice(2, 4)),
			hex_bit_to_number(hex.slice(4, 6)),
			hex_bit_to_number(hex.len() >= 8 ? hex.slice(6, 8) : "ff")
		)
	} else {
		return from_255(
			(hex & 0xFF000000) >> 24,
			(hex & 0x00FF0000) >> 16,
			(hex & 0x0000FF00) >> 8,
			(hex & 0x000000FF)
		)
	}
}

colors.random <- function(random_alpha = false) {
	return colors.from_255(
		rand().tofloat() % 255.0,
		rand().tofloat() % 255.0,
		rand().tofloat() % 255.0,
		(random_alpha ? (rand().tofloat() % 255.0) : 255)
	)
}

colors.print <- function(a = null) {
	if(a != null) {
		::print(a)
	} else {
		local str = "\n"
		foreach(i, v in colors) str += i + " = " + v.tostring() + "\n"
		display(str + "\n")
	}
}

function hex_letter_to_number(hex) {
	switch(hex) {
		case "a":
			return 10
		break
		case "b":
			return 11
		break
		case "c":
			return 12
		break
		case "d":
			return 13
		break
		case "e":
			return 14
		break
		case "f":
			return 15
		break
		default:
			return hex.tointeger()
		break
	}
}

function hex_bit_to_number(hex) {
	return (hex_letter_to_number(hex.slice(0, 1)) * 16) + hex_letter_to_number(hex.slice(1))
}

api_table().colors <- colors.setdelegate(colors_delegate)


// console.nut

// This file adds new stuff to the console so it can function.

::console <- getconsttable()

/*
local help_text = "Heres some commands to try:\n"
+ "`liborange_respond(\"github\")` - links you to the Orange Library Github repo. Check the wiki there for tips on how to use the Orange Library.\n"
+ "`liborange_respond(\"github\")`\n"
+ "Note: You can scroll through the console with the PageUp and PageDown keys."

function console::liborange_init_script_loader() {
	Level.liborange_console_response <- ""
	local wait_for_response = function(message = null) {
		if(message != null) display(message)
		while(Level.liborange_console_response == "") wait(0.01)
		local resp = Level.liborange_console_response
		Level.liborange_console_response = ""
		return resp
	}
	Level.liborange_script_loader_thread <- OThread(function() {
		display(@"Welcome to the Orange Library script loader. Type `liborange_respond(""help"")` for help.")
		while(wait(0.01) == null) {
			local response = wait_for_response().tolower()
			if(response == "help") display(help_text)
		}
	})
	Level.liborange_script_loader_thread.call()
}

function console::liborange_respond(message) Level.liborange_console_response = message
*/

function console::liborange_init_script_loader() try {
	load_level("levels/test2/script_loader.stl")
} catch(e) {
	api_table().init_script_loader_titlescreen()
}

function console::liborange_add_global_script(thing) Level.liborange_loaded_script_class <- thing

Level.liborange_console_response <- ""
function console::liborange_respond(message) {
	Level.liborange_console_response = message
	sector.liborange.get_signal("console_response").call(message)
}

setconsttable(console)

// grumbel.nut

function get_version() {
	if("do_the_funny" in Level) return 1
	if("grumbel_thread" in Level || "grumbel_v2" in Level) return 2
	return 0
}

function get_data(key) try {
	if(key == "version") return get_version()
	switch(get_version()) {
		case 1:
			local newkey = "grumbel_" + key.slice(0, -2)
			if(newkey in get_sector() && type(get_sector()[newkey]) == "array") {
				if(endswith(key, "_x")) return get_sector()[newkey][0]
				if(endswith(key, "_y")) return get_sector()[newkey][1]
			}
			return get_sector()["grumbel_" + key]
		break
		case 2:
			return get_sector().grumbel[key]
		break
	}
} catch(e) {}

function set_data(key, value) try {
	switch(get_version()) {
		case 1:
			local newkey = "grumbel_" + key.slice(0, -2)
			if(newkey in get_sector() && type(get_sector()[newkey]) == "array") {
				if(endswith(key, "_x")) return get_sector()[newkey][0] = value
				if(endswith(key, "_y")) return get_sector()[newkey][1] = value
			}
			return get_sector()["grumbel_" + key] = value
		break
		case 2:
			return get_sector().grumbel[key] = value
		break
	}
} catch(e) {}

api_table().grumbel_exists <- function() return get_version() != 0

api_table().freeze_grumbel <- function(f = true) return set_data("idle", f)
api_table().unfreeze_grumbel <- function(f = true) return set_data("idle", !f)

api_table().set_grumbel_pos <- function(x, y) {
	set_data("pos_x", x)
	set_data("pos_y", y)
}

api_table().get_grumbel_pos_x <- function() return get_data("pos_x")
api_table().get_grumbel_pos_y <- function() return get_data("pos_y")

api_table().set_grumbel_sprite <- function(path, use_cape = true) try {
	if(get_version() == 1) {
		sector.grumbel.set_visible(false)
		delete sector.grumbel
		sector.grumbel <- FloatingImage(path)
		sector.grumbel.set_anchor_point(ANCHOR_TOP_LEFT)
		sector.grumbel.set_layer(600)
		sector.grumbel.set_visible(true)
		sector.grumbel.set_action("invisible")
	} else {
		sector.grumbel_image.set_visible(false)
		delete sector.grumbel_image
		sector.grumbel_image <- FloatingImage(path)
		sector.grumbel_image.set_anchor_point(ANCHOR_TOP_LEFT)
		sector.grumbel_image.set_layer(600)
		sector.grumbel_image.set_visible(true)
		sector.grumbel_image.set_action("invisible")
	}

	sector.grumbel_cape.set_visible(false)
	delete sector.grumbel_cape
	sector.grumbel_cape <- FloatingImage(use_cape ? path : "../../images/objects/invisible/invisible.png")
	sector.grumbel_cape.set_anchor_point(ANCHOR_TOP_LEFT)
	sector.grumbel_cape.set_layer(599)
	sector.grumbel_cape.set_visible(true)
	sector.grumbel_cape.set_action("invisible")
} catch(e) {}

//api_table().set_checkpoints <- function(amount)
//api_table().get_checkpoints <- function()

api_table().set_grumbel_data <- function(key, value) return set_data(key, value)
api_table().get_grumbel_data <- function(key) return get_data(key)

//api_table().display_grumbel_info <-

// location.nut

api_table().in_level <- function() try {
    return sector != null
} catch(e) return false

api_table().in_worldmap <- function() try {
    return worldmap != null
} catch(e) return false

api_table().on_titlescreen <- function() return api_table().in_level() && "logo" in sector

// Nasty workaround. If you have a better soloution please let me know.
api_table().in_editor <- function() return sector.Tux.get_x() == 0 && sector.Tux.get_y() == 0 && sector.Tux.get_velocity_x() == 0 && sector.Tux.get_velocity_y() == 0

// multiplayer.nut

api_table().get_players <- get_players

api_table().for_all_players <- function(func = function(){}) {
	if(type(func) == "string") func = compilestring(func)
	local retarray = {}
	foreach(i, v in get_players()) {
		local that = this
		that.Tux <- v
		retarray[i] <- rawcall(func, that)
	}
	return retarray
}

api_table().nearest_player <- get_nearest_player


// rand.nut

class ORand {
	seed = 0
	rseed = 0

	constructor(start_seed = rand()) {
		srand(start_seed)
	}

	function rand() return rseed = (rseed * 1103515245 + 12345) & RAND_MAX
	function srand(_seed) {
		seed = _seed
		rseed = _seed
	}

	function get_seed() return seed
	function get_current_seed() return rseed
}

api_table().Rand <- ORand

// when the compatibility is retro
local compatrand = ORand()
api_table().srand <- function(seed) return compatrand.srand(seed)
api_table().rand_seed <- function() return compatrand.rand()
api_table().get_seed <- function() return compatrand.get_seed()


// scripted_object.nut

class OScriptedObject extends OObject {
	bound_objects = {}

	function bind_object(object, ...) {
		local offset
		switch(vargv.len()) {
			case 1:
				offset = vargv[0]
			break
			case 2:
				offset = OVector(vargv[0], vargv[1])
			break
			default:
				throw "wrong number of parameters"
			break
		}
		bound_objects[object] <- offset
	}

	function init_bound_objects() {
		api_table().get_callback("process").connect(function() {
			foreach(i, v in bound_objects) {
				i.set_pos(get_pos_x() + v.x, get_pos_y() + v.y)
				set_pos(i.get_x() - v.x, i.get_y() - v.y)
			}
		}.bindenv(this))
		api_table().init_signals()
	}

	function get_pos() {
		return OVector(get_x(), get_y())
	}

	function set_pos(...) {
		switch(vargv.len()) {
			case 1:
				object.set_pos(vargv[0].x, vargv[0].y)
			break
			case 2:
				object.set_pos(vargv[0], vargv[1])
			break
			default:
				throw "wrong number of parameters"
			break
		}
	}
}


// scriptloader.nut

//import("orange-api/text.nut") // required

enum keys {
	TEXT
	SWAP
	FUNC
	BACK
	CUSTOM
	EXIT
}

enum values {
	NULL
	INT
	FLOAT
	STRING
	BOOL
	ENUM
}

enum errors {
	OK
	INFO
	WARNING
	ERROR
}

// menu stuff

function load_previous_scripts() {
	local newtab = [action.text("Load Previous Scripts")]
	if("liborange_previously_loaded_scripts" in Level && Level.liborange_previously_loaded_scripts.len() > 0) {
		foreach(i, v in Level.liborange_previously_loaded_scripts) {
			newtab.push(action.run((i in Level.liborange_loaded_scripts ? "Reload": "Load") + " Script \"" + i + "\"", function(){load_script(i)}))
		}
	} else {
		newtab.push(action.text("No scripts previously loaded. Check \"Load a New Script\" to load one."))
	}
	newtab.push(action.back())
	swap_menu(newtab)
}

function load_script(name = null) {
	if(name == null) name = get_item_from_name("Script Name").string
	if(name == "") {
		display_info("Could not find the desired script because you entered no text.", errors.ERROR)
		return
	}
	/*
	try {
		import(name + (endswith(name, ".nut") ? "" : ".nut"))
	} catch(e) try {
		import("liborange-scripts/" + name + (endswith(name, ".nut") ? "" : ".nut"))
	} catch(e) {
		display_info("Could not find the desired script \"" + name + "\". You spelling everything correctly?", errors.ERROR)
		return
	}
	*/
	try {
		//::print(name)
		import(name)
	} catch(e) try {
		//::print("liborange-scripts/" + name)
		import("liborange-scripts/" + name)
	} /*catch(e) try {
		//::print(name + ".nut")
		import(name + ".nut")
	} catch(e) try {
		//::print("liborange-scripts/" + name + ".nut")
		import("liborange-scripts/" + name + ".nut")
	} */catch(e) {
		display_info("Could not find the desired script \"" + name + "\". You spelling everything correctly?", errors.ERROR)
		return
	}
	if(!("liborange_loaded_scripts" in Level)) Level.liborange_loaded_scripts <- {}
	Level.loaded_script_thread <- OThread(load_script_thread)
	Level.loaded_script_thread.call()
	if(name in Level.liborange_loaded_scripts) delete Level.liborange_loaded_scripts[name]
	Level.liborange_loaded_scripts[name] <- (type(Level.liborange_loaded_script_class) == "class" ?
																				Level.liborange_loaded_script_class() :
																				Level.liborange_loaded_script_class)
	Level.liborange_loaded_script_class = null
	display_info("Script successfully loaded!", errors.OK)
	if(!("liborange_previously_loaded_scripts" in Level)) Level.liborange_previously_loaded_scripts <- {}
	Level.liborange_previously_loaded_scripts[name] <- name
}

function manage_scripts() {
	local newtab = [action.text("Manage Scripts")]
	if("liborange_loaded_scripts" in Level && Level.liborange_loaded_scripts.len() > 0) {
		foreach(i, v in Level.liborange_loaded_scripts) {
			newtab.push(action.run("Manage Script \"" + i + "\"", function(){manage_script(Level.liborange_loaded_scripts[i])}))
		}
	} else {
		newtab.push(action.text("No scripts currently loaded. Check \"Load a New Script\" to load one."))
	}
	newtab.push(action.swap("Back", "script_loader"))
	swap_menu(newtab)
}

function manage_script(script) {
	local newtab = script.settings
	if(newtab.len() > 0 && newtab[0].orange_API_key != keys.TEXT) newtab = [action.text("Manage Script")].extend(newtab)
	local found = false
	foreach(v in newtab) if(v.text.tolower() == "back") found = true
	if(!found) newtab.push(action.run("Back", manage_scripts))
	swap_menu(newtab)
}

local menus = {
	main = [
		action.text("liborange Menu")
		action.swap("Script Loader", "script_loader")
		action.swap("Addon Settings", "addon_settings")
		action.swap("liborange Settings", "liborange_settings")
		//action.swap("Test Data Types", "test")
		action.exit()
	]
	script_loader = [
		action.text("Script Loader")
		action.run("Load a Previously Loaded Script", load_previous_scripts)
		action.swap("Load a New Script", "new_script")
		action.run("Manage Scripts", manage_scripts)
		action.swap("Back", "main")
	]
	new_script = [
		action.text("Load a New Script")
		data.string("Script Name")
		action.run("Load Script", load_script)
		action.back()
	]
	addon_settings = [
		action.text("Addon Settings")
		action.back()
		action.text("Coming Soon")
	]
	liborange_settings = [
		action.text("liborange Settings")
		data.enums("Text Resizing", 0, "On", "Off", "Adaptive")
		action.back()
	]
	test = [
		action.text("Test Data Types")
		data.integer("Integer", 0, -10, 10)
		data.float("Float")
		data.string("String")
		data.bool("Boolean")
		data.nil("Null")
		action.back()
	]
}

// other stuff

function load_script_thread() {
	while(true) {
		foreach(v in Level.liborange_loaded_scripts) {
			try {
				if(sector && !("custom_script_disable" in sector)) OThread(v._sector()).call()
			} catch(e) {
				try {
					if(worldmap && !("custom_script_disable" in worldmap)) OThread(v._worldmap()).call()
				} catch(e){

				}
			}
		}
		wait_for_screenswitch()
	}
}

function get_value_from_type(value) {
	if(type(value) == "table" && "orange_API_value" in value) {
		return value.orange_API_value
	} else if(type(value) == "integer") {
		return values.INT
	} else if(type(value) == "float") {
		return values.FLOAT
	} else if(type(value) == "string") {
		return values.STRING
	} else if(type(value) == "bool") {
		return values.BOOL
	}
	return values.NULL
}

function set_settings(name, value, item = menus.liborange_settings) // NOTE: send data types (AKA data.<something>()), not raw values
	item.apply(function[this](v, i, arr) {
		if(v.text == name) {
			return value
		} else return v
	})

function get_settings(name, item = menus.liborange_settings, enum_name = false)
		foreach(v in item)
			if(v.text == name)
				switch(v.orange_API_value) {
					case values.NULL:
						return null
					case values.INT:
					case values.FLOAT:
						return v.num
					case values.STRING:
						return v.string
					case values.BOOL:
						return v.bool
					case values.ENUM:
						return v.enums[v.index][enum_name.tointeger()]
				}

class OliborangeMenuText extends OMenuText {
	titlescreen_mode = null

	constructor(name, titlescreen = false) {
		titlescreen_mode = titlescreen
		//if(titlescreen_mode) {
		//	set_text("Inputs cannot be inputted on the titlescreen. Please make an input to confirm youre not on the titlescreen. A good place to")
		//}
		base.constructor(name)
		set_wrap_width(sector.Camera.get_screen_width())
		swap_menu("main")
	}

	function draw_menu() {
		local drawtext = ""
		local drawnum = 0

		if(drawnum != current_item) set_font("big")

		foreach(i, v in current_menu) {
			local drawline = (drawnum == current_item ? "> " : "  ")
			switch(v.orange_API_key) {
				case keys.CUSTOM:
					drawline += v.text + " : "
					switch(v.orange_API_value) {
						case values.NULL:
							drawline += "<null>"
							break
						case values.INT:
							drawline += v.num
							break
						case values.FLOAT:
							drawline += v.num + (v.num == v.num.tointeger() ? ".0" : "")
							break
						case values.STRING:
							drawline += v.prefix + v.string + v.suffix
							break
						case values.BOOL:
							drawline += v.bool ? v.true_text : v.false_text
							break
						case values.ENUM:
							drawline += "<- " + v.enums[v.index][0] + "->"
							break
						default:
							drawline += "<unknown>"
							break
					}
					break
				default:
					drawline += v.text
			}
			drawtext += drawline + (drawnum == current_item ? " <" : "") + "\n"

			switch(get_settings("Text Resizing")) {
				case 1:
					set_font("big")
					break
				case 0:
					if(drawline.len() >= 38 && v.orange_API_key != keys.TEXT) {
						set_font("small")
					} else if(drawline.len() >= 30 && v.orange_API_key != keys.TEXT) set_font("normal")
				case 2:
					if(drawnum == current_item && drawline.len() > 38 && v.orange_API_key != keys.TEXT) {
						set_font("small")
					} else if(drawnum == current_item && drawline.len() > 30 && v.orange_API_key != keys.TEXT) set_font("normal")
					break
			}
			drawnum++
		}
		set_text(start_info + "\n" + drawtext)
	}

	function swap_menu(new_menu) {
		current_item = 0
		last_menu = current_menu
		if(type(new_menu) == "string") {
			current_menu = clone menus[new_menu]
		} else current_menu = clone new_menu
	}

	function exit() {
		if(titlescreen_mode) {
			grow_out(0.3)
		} else {
			sector.Effect.fade_out(1)
			fade_out(0.5)
			wait(1)
			Level.finish(false)
		}
	}
}

// global class thing for the custom script loader to ensure all functions are there for global scripts
class OGlobalScript {
	settings = []

	function _sector() {}

	function _worldmap() {}

	function _titlescreen() _sector() // temporarily out of order


	function set_setting(name, value, setting) return set_settings(name, value, setting)
	function get_setting(name, setting, enum_name = false) return get_settings(name, setting, enum_name)
}

function hide_player(player) {
	player.set_visible(false)
	player.set_ghost_mode(true)
	player.deactivate()
	player.set_pos(0, 0)
}

api_table().init_script_loader <- function() {
	sector.custom_script_disable <- true
	sector.Text.set_font("big")
	sector.Text.set_back_fill_color(0, 0, 0, 0)
	sector.Text.set_front_fill_color(0, 0, 0, 0)
	sector.Text.set_visible(true)
	/*sector.Thing <- OThread(function() {while(wait(0.01) == null) {*/foreach(i, player in get_players()) hide_player(player)//}})
	//sector.Thing.call()
	OliborangeMenuText("Text")
}

api_table().init_script_loader_titlescreen <- function() {
	sector.Text.set_font("big")
	sector.Text.set_pos(50, 0)
	sector.Text.grow_in(0.3)
	sector.Text.set_anchor_point(ANCHOR_LEFT)
	OliborangeMenuText(TextObject(), true)
}

api_table().global_script <- OGlobalScript


// state.nut

enum forbidden_keys {
	NULL
	ARRAY
	CLASS
	INSTANCE
	WEAKREF
	THREAD
}

function object_to_state(object) {
	local retobj
	if(object == null) {
		retobj = {orange_API_key = forbidden_keys.NULL}
	} else if(type(object) == "array") {
		retobj = {orange_API_key = forbidden_keys.ARRAY}
		foreach(i, v in object) retobj[i.tostring()] <- object_to_state(v)
	} else if(type(object) == "class") {
		retobj = {orange_API_key = forbidden_keys.CLASS}
		foreach(i, v in object) retobj[i] <- object_to_state(v)
	} else if(type(object) == "weakref") {
		retobj = {orange_API_key = forbidden_keys.WEAKREF}
		retobj.reference <- object_to_state(object.ref())
	} else retobj = object
	::display(retobj)
	return retobj
}

function state_to_object(object) if("orange_API_key" in object) {
	local retobj
	switch(object.orange_API_key) {
		case forbidden_keys.NULL:
			break // do nothing because retobj is already null
		case forbidden_keys.ARRAY:
			retobj = []
			for(local i = 0; i.tostring() in object; i++) retobj.push(state_to_object(object[i.tostring()]))
			break
			case forbidden_keys.CLASS:
				retobj = class{}
				foreach(i, v in object) if(i != "orange_API_key") retobj[i] <- state_to_object(v)
				break
			case forbidden_keys.WEAKREF:
				if(!("weakref_references" in api_storage())) api_storage().weakref_references <- []
				api_storage().weakref_references.push(object.reference)
				retobj = state_to_object(object.reference).weakref()
		default:
			retobj = object
			break
	}
	::display(retobj)
	return retobj
} else return object

api_table().save_state <- function() {}

api_table().load_state <- function() {}

api_table().object_to_state <- object_to_state
api_table().state_to_object <- state_to_object


// table.nut

local actual_indent = "   "

api_table().table_to_string <- function(list, indent = actual_indent, index = null) {
	local liststring = indent.slice(0, indent.len() - 3) + ((index == null) ? list.tostring() : index.tostring()) + " = " + ((type(list) == "table") ? "{" : "[") + " (" + type(list) + ")\n"
	foreach(i, v in list) {
		if(type(v) == "array" || type(v) == "table") {
			if(v.len() > 0) {
				api_table().table_to_string(v, indent + actual_indent, i)
			} else liststring += indent + actual_indent + "<empty " + type(v) + ">\n"
		} else {
			liststring += indent + i.tostring() + " = " + v.tostring() + " (" + type(v) + ")\n"
		}
	}
	liststring += indent.slice(0, indent.len() - 3) + ((type(list) == "table") ? "}" : "]") + " (end of " + ((index == null) ? list.tostring() : index.tostring()) + ")"
	return liststring
}

api_table().display_table <- function(table) {
	display("\n" + api_table().table_to_string(table) + "\n")
}

// test.nut

local is_milling = false
local milli = 0

api_table().help <- help

api_table().ping <- function() {
	is_milling = true
	milli = 0
	OThread(function() {
		while(is_milling) {
			wait(0.01)
			milli++
		}
	}).call()
	is_milling = false
	::display("pong! (" + milli.tostring() + " milliseconds)")
}

// tether.nut

class OTether {
	tethered_objects = null

	constructor(name, ...) {
		tethered_objects = []
		foreach(v in vargv) {
			switch(::type(v)) {
				case "string":
					tethered_objects.push(::get_sector()[v])
				break
				default:
					tethered_objects.push(v)
				break
			}
		}
		if(name != "" && name != null) ::get_sector()[name] <- this
	}

	function _set(key, value) {
		foreach(v in tethered_objects)
			if(key in v)
				v[key] = value
	}

	function _get(key) {
		local retval = []
		local functions = true
		foreach(i, v in tethered_objects)
			if(key in v) {
				retval.insert(i, v[key])
				if(::type(v[key]) != "function") functions = false
			}
		if(functions) {
			return function[this](...) {
				local retval2 = []
				foreach(i, v in retval)
					retval2.push(v.acall([tethered_objects[i]].extend(vargv)))
				return retval2
			}
		} else {
			return retval
		}
	}
}


// tilemap.nut

local alternating_tiles = []

function tilemap_get_width(tilemap) {
	local inc = 0
	while(true) {
		local oldid = tilemap.get_tile_id(inc, 0)
		tilemap.change(inc, 0, 1)
		if(tilemap.get_tile_id(inc, 0) == 1) {
			tilemap.change(inc, 0, oldid)
			inc++
		} else break
	}
	tilemap.change(0, 1, 0)
	return inc
}

function tilemap_get_height(tilemap) {
	local inc = 0
	while(true) {
		local oldid = tilemap.get_tile_id(0, inc)
		tilemap.change(0, inc, 1)
		if(tilemap.get_tile_id(0, inc) == 1) {
			tilemap.change(0, inc, oldid)
			inc++
		} else break
	}
	tilemap.change(0, 1, 0)
	return inc
}

function alternate_tile(tilemap, x, y, framerate, ids, ...) {
	local tile_ids = []
	if(type(ids) == "array") {
		tile_ids = ids
	} else {
		tile_ids.push(ids)
		foreach(v in vargv) tile_ids.push(v)
	}
	alternating_tiles.push({
		tilemap = tilemap
		x = x
		y = y
		framerate = framerate
		ids = tile_ids
		current_id = 0
	})

	if(!("alternating_tiles_thread" in api_storage())) {
		api_storage().alternating_tiles_thread <- newthread(function(table) {
			local i = 0
			while(true) {
				foreach(v in table.ref()) {
					if(i % v.framerate == 0) {
						v.tilemap.change(v.x, v.y, v.ids[v.current_id % v.ids.len()])
						v.current_id++
					}
				}
				i = /*i > 60 ? 0 :*/ i + 1
				wait(0.01)
			}
		})
		api_storage().alternating_tiles_thread.call(alternating_tiles.weakref())
	}
}

api_table().alternate_tiles <- function(tilemap, id, framerate, ids, ...) {
	local tile_ids
	if(type(ids) == "array") {
		tile_ids = ids
	} else {
		tile_ids = [ids].extend(vargv)
	}
	for(local x = 0; x < tilemap_get_width(tilemap); x++)
		for(local y = 0; y < tilemap_get_height(tilemap); y++)
			if(tilemap.get_tile_id(x, y) == id) alternate_tile(tilemap, x, y, framerate, tile_ids)
}

api_table().tilemap_get_width <- tilemap_get_width
api_table().tilemap_get_height <- tilemap_get_height
api_table().alternate_tile <- alternate_tile


// time.nut

class OTimer extends OSignal {
	time = 0
	vars = []

	function call(_time, ...) {
		time = _time
		vars = vargv
		local a = newthread(thread_func.bindenv(this))
		api_table().thread_fix(a)
		a.call()
	}

	function thread_func() {
		wait(time)
		OSignal.call.acall([this, time].extend(vars))
	}
}

class OCallbackTimer extends OCallback {
	time = OTimer.time
	vars = OTimer.vars

	call = OTimer.call

	function thread_func() {
		wait(time)
		OCallback.call.acall([this, time].extend(vars))
	}
}

::OSignalTimer <- OTimer // consistency

api_table().Timer <- OTimer
api_table().SignalTimer <- OSignalTimer
api_table().CallbackTimer <- OCallbackTimer


// trampoline.nut

if(WORLDMAP_GUARD) {

class OTrampoline extends OObject {
	direction = null
	speed_y = 0
	speed_multiplier = 0

	constructor(obj, dir = "up", y = -450, mult = 2) {
		base.constructor(obj)
		direction = dir.tolower()
        speed_y = y
		speed_multiplier = mult

		set_action("normal")
		set_action("normal-" + direction)
	}

	function press() {
		if(collided_with_any_player(get_x(), get_y(),
									((direction == "up" || direction == "down") ? 30 : 16),
									((direction == "up" || direction == "down") ? 16 : 30), direction).len() > 0)
			force_press(get_nearest_player(get_x(), get_y()))
	}

	function force_press(player = sector.Tux) {
		local speed

		if(direction == "up") {
			if(player.get_bonus() == "airflower") {
			speed = speed_y
			* (player.get_input_held("jump") || player.get_input_held("down") ? speed_multiplier : 1)
			- 80
			+ (player.get_input_held("down") ? 10 : 0)
			} else {
			speed = speed_y
			* (player.get_input_held("jump") || player.get_input_held("down") ? speed_multiplier : 1)
			+ (player.get_input_held("down") ? 100 : 0)
			}
		} else speed = speed_y * speed_multiplier * -1

		player.set_velocity(player.get_velocity_x(), speed)
		play_sound("sounds/trampoline.wav")
		set_action("swinging")
		set_action("swinging-" + direction)
		wait(0.21875)
		set_action("normal")
		set_action("normal-" + direction)
	}

	//push = press
	//unpush = unpress
	//force_push = force_press
}

api_table().Trampoline <- OTrampoline

}
